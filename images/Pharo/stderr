
2020-04-11 21:40:52 002 477523 Server Socket Bound 0.0.0.0:8080
2020-04-11 21:40:52 003 397233 Server Socket Bound 0.0.0.0:1701
2020-04-11 21:40:52 004 195940 Started ZnManagingMultiThreadedServer HTTP port 1701
2020-04-11 21:40:52 005 477523 Server Socket Released 0.0.0.0:8080
2020-04-11 21:40:52 006 127117 Stopped ZnManagingMultiThreadedServer HTTP port 8080
2020-04-11 21:40:52 007 156227 Server Socket Bound 0.0.0.0:8080
2020-04-11 21:40:52 008 127117 Started ZnManagingMultiThreadedServer HTTP port 8080mandLineHandler>>installSourceFiles in Block: [ :reference | self installSourceFile: reference ]...etc...
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles in Block: [ sourceFiles do: [ :reference | self installSourc...etc...
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand: in Block: [ aCommandLinehandler activateWith: commandLine ]
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ] in [ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate in Block: [ self...
BlockClosure>>on:do:
[ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate in Block: [ [ self...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mde the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate in Block: [ self...
BlockClosure>>on:do:
[ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate in Block: [ [ self...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m | json value: [ json string: dep name ] ] ] ] in [ json key: 'name' value: grPackage name.
json
	key: 'dependencies'
	value: [ json
			array: [ grPackage dependencies
					do: [ :dep | json value: [ json string: dep name ] ] ] ] ] in [ :grPackage | 
json
	object: [ json key: 'name' value: grPackage name.
		json
			key: 'dependencies'
			value: [ json
					array: [ grPackage dependencies
							do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] in [ GRPackage grPackages
	do: [ :grPackage | 
		json
			object: [ json key: 'name' value: grPackage name.
				json
					key: 'dependencies'
					value: [ json
							array: [ grPackage dependencies
									do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] ] in JQJsonFunctionalTest>>seasidePackagesOn: in Block: [ json...
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
[ canvas render: anObject ] in WAJsonKeyValueBrush(WAJsonBrush)>>with: in Block: [ canvas render: anObject ]
BlockClosure>>jsonOn:
[0m[31mMessageNotUnderstood: receiver of "name" is nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #name
[ json string: dep name ] in [ :dep | json value: [ json string: dep name ] ] in [ grPackage dependencies
	do: [ :dep | json value: [ json string: dep name ] ] ] in [ json
	array: [ grPackage dependencies
			do: [ :dep | json value: [ json string: dep name ] ] ] ] in [ json key: 'name' value: grPackage name.
json
	key: 'dependencies'
	value: [ json
			array: [ grPackage dependencies
					do: [ :dep | json value: [ json string: dep name ] ] ] ] ] in [ :grPackage | 
json
	object: [ json key: 'name' value: grPackage name.
		json
			key: 'dependencies'
			value: [ json
					array: [ grPackage dependencies
							do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] in [ GRPackage grPackages
	do: [ :grPackage | 
		json
			object: [ json key: 'name' value: grPackage name.
				json
					key: 'dependencies'
					value: [ json
							array: [ grPackage dependencies
									do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] ] in JQJsonFunctionalTest>>seasidePackagesOn: in Block: [ json string: dep name ]
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
[ canvas render: anObject ] in WAJsonValueBrush(WAJsonBrush)>>with: in Block: [ canvas render: anObject ]
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
WAJsonCanvas(WACanvas)>>nest:
WAJsonCanvas>>nest:
WAJsonValueBrush(WABrush)>>with:
WAJsonValueBrush(WAJsonBrush)>>with:
WAJsonCanvas>>value:
[ :dep | json value: [ json string: dep name ] ] in [ grPackage dependencies
	do: [ :dep | json value: [ json string: dep name ] ] ] in [ json
	array: [ grPackage dependencies
			do: [ :dep | json value: [ json string: dep name ] ] ] ] in [ json key: 'name' value: grPackage name.
json
	key: 'dependencies'
	value: [ json
			array: [ grPackage dependencies
					do: [ :dep | json value: [ json string: dep name ] ] ] ] ] in [ :grPackage | 
json
	object: [ json key: 'name' value: grPackage name.
		json
			key: 'dependencies'
			value: [ json
					array: [ grPackage dependencies
							do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] in [ GRPackage grPackages
	do: [ :grPackage | 
		json
			object: [ json key: 'name' value: grPackage name.
				json
					key: 'dependencies'
					value: [ json
							array: [ grPackage dependencies
									do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] ] in JQJsonFunctionalTest>>seasidePackagesOn: in Block: [ :dep | json value: [ json string: dep name ] ]
OrderedCollection>>do:
[ grPackage dependencies
	do: [ :dep | json value: [ json string: dep name ] ] ] in [ json
	array: [ grPackage dependencies
			do: [ :dep | json value: [ json string: dep name ] ] ] ] in [ json key: 'name' value: grPackage name.
json
	key: 'dependencies'
	value: [ json
			array: [ grPackage dependencies
					do: [ :dep | json value: [ json string: dep name ] ] ] ] ] in [ :grPackage | 
json
	object: [ json key: 'name' value: grPackage name.
		json
			key: 'dependencies'
			value: [ json
					array: [ grPackage dependencies
							do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] in [ GRPackage grPackages
	do: [ :grPackage | 
		json
			object: [ json key: 'name' value: grPackage name.
				json
					key: 'dependencies'
					value: [ json
							array: [ grPackage dependencies
									do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] ] in JQJsonFunctionalTest>>seasidePackagesOn: in Block: [ grPackage dependencies...
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
[ canvas render: anObject ] in WAJsonArrayBrush(WAJsonBrush)>>with: in Block: [ canvas render: anObject ]
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
WAJsonCanvas(WACanvas)>>nest:
WAJsonCanvas>>nest:
WAJsonArrayBrush(WABrush)>>with:
WAJsonArrayBrush(WAJsonBrush)>>with:
WAJsonCanvas>>array:
[ json
	array: [ grPackage dependencies
			do: [ :dep | json value: [ json string: dep name ] ] ] ] in [ json key: 'name' value: grPackage name.
json
	key: 'dependencies'
	value: [ json
			array: [ grPackage dependencies
					do: [ :dep | json value: [ json string: dep name ] ] ] ] ] in [ :grPackage | 
json
	object: [ json key: 'name' value: grPackage name.
		json
			key: 'dependencies'
			value: [ json
					array: [ grPackage dependencies
							do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] in [ GRPackage grPackages
	do: [ :grPackage | 
		json
			object: [ json key: 'name' value: grPackage name.
				json
					key: 'dependencies'
					value: [ json
							array: [ grPackage dependencies
									do: [ :dep | json value: [ json string: dep name ] ] ] ] ] ] ] in JQJsonFunctionalTest>>seasidePackagesOn: in Block: [ json...
BlockClosure>>jsonOn:
WAJsonCanvas>>render:
[ canvas render: anObject ] in WAJsonKeyValueBrush(WAJsonBrush)>>with: in Block: [ canvas render: anObject ]
BlockClosure>>jsonOn:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ | aWidget |
aWidget := aSystemWindow openAsIs.
self activeHand mouseFocus: aWidget.
[ aWidget world notNil ]
	whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] in ClyFullBrowser(Morph)>>openModal: in Block: [ | aWidget |...
BlockClosure>>ensure:
ClyFullBrowser(Morph)>>openModal:
ClyBrowserSearchDialogWindow>>openOn:withTitle:thenDo:
ClyBrowserSearchDialogWindow>>requestSingleObject:from:
ClyFindClassCommand>>execute
ClyGlobalContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand in Block: [ self prepareCommandForExecution....
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
CmdShortcutActivation>>tryExecuteCommandInContext:byEvents:
[ :shortcut | 
executed := shortcut
	tryExecuteCommandInContext: context
	byEvents: anEventBuffer.
executed
	ifTrue: [ ^ self ] ] in CmdKMDispatcher>>dispatch: in Block: [ :shortcut | ...
SortedCollection(SequenceableCollection)>>select:thenDo:
CmdShortcutActivation class(ClassAnnotation class)>>visibleInstancesInContext:do:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch: in Block: [ :targetToDispatch | ...
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
FTTableMorph(Morph)>>dispatchKeystrokeForEvent:
FTTableMorph(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
FTTableMorph(Morph)>>handleKeystroke:
[0m[31mUser Interrupt
[0mWeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess in Block: [ self finalizationProcess ]
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mNotFound: a WATodoItem not found in OrderedCollection
[0mOrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove: in Block: [ self errorNotFound: oldObject ]
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
WATodoItem>>remove
[ :passengers | passengers first remove ] in [ html checkbox id: 'toggle-all'.
html label
	for: 'toggle-all';
	with: 'Mark all as complete'.
html unorderedList
	id: 'todo-list';
	script:
		(html jQuery this
			on: 'click'
			selector: '.toggle'
			do:
				((html jQuery ajax
					serializeWithHidden: (html jQuery expression: (JSStream on: 'event.target')))
					asFunction: #(event)));
	script:
		(html jQuery this
			on: 'click'
			selector: '.destroy'
			do:
				((html jQuery ajax
					callback: [ :passengers | passengers first remove ]
						passengers:
						((html jQuery expression: (JSStream on: 'event.target')) closest: 'li');
					onComplete:
						((html jQuery expression: (JSStream on: 'event.target')) closest: 'li')
							remove) asFunction: #(event)));
	script:
		(html jQuery this
			on: 'click'
			selector: '.view>label'
			do:
				((((html jQuery expression: (JSStream on: 'event.target')) hide
					closest: 'li') find: '.edit') show asFunction: #(event)));
	script:
		(html jQuery this
			on: 'change'
			selector: '.edit'
			do:
				((html jQuery ajax
					serialize: (html jQuery expression: (JSStream on: 'event.target'));
					callback: [ :passengers | currentItem := passengers first ]
						passengers: ((html jQuery expression: (JSStream on: 'event.target')) closest: 'li');
					callback: [ :id | itemId := id ]
						value: (JSStream on: '$(event.target).closest("li").get(0).id');
					script: [ :s | 
						s
							<< (((s jQuery id: itemId) find: 'label') html: currentItem description) ];
					onComplete:
						(((html jQuery expression: (JSStream on: 'event.target'))
							closest: 'li') find: '.edit') hide
							,
								(((html jQuery expression: (JSStream on: 'event.target'))
									closest: 'li') find: 'label') show) asFunction: #(event)));
	with: [ self todos do: [ :todoItem | todoItem renderOn: html ] ] ] in WATodo>>renderTodosOn: in Block: [ :passengers | passengers first remove ]
[ :value | 
aBlock
	value:
		((GRPlatform
			subStringsIn: value value
			splitBy: $,
			collect: [ :each | self renderContext callbacks passengerAt: each ])
			reject: [ :each | each isNil ]) ] in JQAjax>>callback:passengers: in Block: [ :value | ...
BlockClosure>>valueWithPossibleArguments:
WAValueCallback>>evaluateWithArgument:
WAValueCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle: in Block: [ :callback | callback evaluateWithFieldValues: (f...etc...
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction in Block: [ self basicPerformAction ]
BlockClosure>>on:do:
WADebugErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo: in Block: [ currentHandler handleExceptionsDuring: aBlock ]
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction in Block: [ super performAction ]
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle: in Block: [ self filter handleFiltered: aRequestContext ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in WACurrentRequestContext(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
WACurrentRequestContext(DynamicVariable)>>value:during:
WACurrentRequestContext class(DynamicVariable class)>>value:during:
[0m[31mUser Interrupt
[0m[ :indicator | 
index := index + 1.
(self
	isScrollMustBeChecked: index
	withLeft: boundsLeft
	andRight: boundsRight)
	ifTrue: [ indicator check.
		firstFound
			ifFalse: [ pagerModel virtualFirstVisiblePageIndex: index.
				firstFound := true ] ]
	ifFalse: [ "uncheck only if not focused"
		indicator isFocused
			ifFalse: [ indicator uncheck ].
		firstFound & (lastFound = false)
			ifTrue: [ pagerModel virtualLastVisiblePageIndex: index - 1.
				lastFound := true ] ] ] in GLMPagerButtonsPaneBrick>>markButtonsInside: in Block: [ :indicator | ...
OrderedCollection>>do:
GLMPagerButtonsPaneBrick>>markButtonsInside:
GLMPagerButtonsPaneBrick>>onScrollBoundsChanged:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
GLMPagerModel>>notifyAll:
GLMPagerModel>>notifyScrollerBoundsChanged:
GLMPagerScrollSlidingBrick>>setPosition:
GLMPagerScrollSlidingBrick>>setWidthAfterResizing
ByteSymbol(Symbol)>>cull:
GLMPagerScrollSlidingBrick(ProtoObject)>>ifNotNil:
GLMPagerBarBrick>>recomputeScrollBar
GLMPagerBarBrick>>onPagePushed:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0mSmallInteger(Magnitude)>>max:
GLMHorizontalLinearLayout(GLMLinearLayout)>>normalizeHeight:of:
GLMBrickLayoutParentState>>updateHeight:on:
GLMHorizontalLinearLayout(GLMLinearLayout)>>updateHeight:
GLMBrickHeightTraverser>>updateDimension:
GLMBrickLayoutParentState>>layout:on:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
[ :each | self layoutAround: each inContext: aBrick ] in GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf: in Block: [ :each | self layoutAround: each inContext: aBric...etc...
OrderedCollection>>do:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf:
GLMBrickLayoutMyselfState>>layout:on:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
GLMBrickLayouter>>layout:
GLMBrickLayouter>>layoutIn:
GLMBrick>>doLayout
GLMBrick>>doLayoutForce
GLMTabSelectorBrick(GLMFoundationBrick)>>extent:
GLMTabSelectorBrick(Morph)>>bounds:
GLMTabSelectorBrick(Morph)>>layoutInBounds:
TableLayout>>layoutLeftToRight:in:
TableLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in LazyTabGroupMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
LazyTabGroupMorph(Morph)>>submorphBounds
LazyTabGroupMorph(Morph)>>privateFullBounds
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle(Object)>>copy
GLMPanelMorph(Morph)>>privateFullBounds
GLMPanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>computeFullBounds
GLMPanelMorph(Morph)>>fullBounds
GLMPanelMorph(Morph)>>position:
GLMPanelMorph(Morph)>>bounds:
GLMPanelMorph(Morph)>>layoutInBounds:
TableLayout>>layoutTopToBottom:in:
TableLayout>>layout:in:
GLMPanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>computeFullBounds
GLMPanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in LazyTabGroupMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
LazyTabGroupMorph(Morph)>>submorphBounds
LazyTabGroupMorph(Morph)>>privateFullBounds
LazyTabGroupMorph(Morph)>>changed
LazyTabGroupMorph(Morph)>>extent:
LazyTabGroupMorph(Morph)>>bounds:
LazyTabGroupMorph(Morph)>>layoutInBounds:
LazyTabGroupMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
DebugSession class>>debuggingActionsFromClass:forPragma:forDebugger:
[ :currentActions :aClass | 
currentActions
	addAll:
		(self
			debuggingActionsFromClass: aClass
			forPragma: aSymbol
			forDebugger: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragma:for: in Block: [ :currentActions :aClass | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragma:for:
[ :currentActions :aSymbol | 
currentActions
	addAll: (self debuggingActionsForPragma: aSymbol for: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragmas:for: in Block: [ :currentActions :aSymbol | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in Array(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
Array(SequenceableCollection)>>do:
Array(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragmas:for:
GTGenericStackDebugger(GTMoldableDebugger)>>allActionsForPragmas:
GTGenericStackDebugger(GTMoldableDebugger)>>actionsForPragmas:
[ :presentation | 
self
	actionsForPragmas: (aSymbolsCollection collect: [ :aSymbol | #gt , aSymbol capitalized ]) ] in GTGenericStackDebugger(GTMoldableDebugger)>>installActionsForRootPragmas:in: in Block: [ :presentation | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMPharoMethodPresentation(GLMPresentation)>>dynamicActions
GLMPharoMethodPresentation(GLMPresentation)>>allActions
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderToolbarForPresentation:inMorph:
[ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ :each | ...
OrderedCollection>>do:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
[0m[31mUser Interrupt
[0mOrderedCollection>>at:
RubTextComposer>>fastFindFirstLineSuchThat:
RubTextComposer>>lineIndexOfCharacterIndex:
RubParagraph>>lineIndexOfCharacterIndex:
RubParagraph>>characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
RubEditingState>>markIndex:pointIndex:
[ self editingState markIndex: markIndex pointIndex: pointIndex ] in RubEditingArea(RubAbstractTextArea)>>markIndex:pointIndex: in Block: [ self editingState markIndex: markIndex pointInde...etc...
RubEditingArea(RubAbstractTextArea)>>handleSelectionChange:
RubEditingArea(RubAbstractTextArea)>>markIndex:pointIndex:
RubEditingArea(RubAbstractTextArea)>>recomputeSelection
RubEditingArea(RubAbstractTextArea)>>textStyle:
RubEditingArea(RubAbstractTextArea)>>font:
RubScrolledTextMorph>>textFont:
GLMMorphicPharoMethodRenderer>>morph
[0m[31mUser Interrupt
[0mGlyphForm(Form)>>depth
FTBitmap>>initializeFromForm:pixelMode:
FreeTypeFace(FT2Face)>>renderGlyphIntoForm:pixelMode:
FreeTypeFace(FT2Face)>>renderGlyphIntoForm:
FreeTypeSubPixelAntiAliasedGlyphRenderer(FreeTypeGlyphRenderer)>>renderGlyph:depth:subpixelPosition:font:
FreeTypeSubPixelAntiAliasedGlyphRenderer(FreeTypeGlyphRenderer)>>glyphOf:colorValue:mono:subpixelPosition:font:
[ FreeTypeGlyphRenderer current
	glyphOf: aCharacter
	colorValue: aColorValue
	mono: monoBoolean
	subpixelPosition: sub
	font: self ] in [ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ FreeTypeGlyphRenderer current...
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
StringMorph>>measureContents
StringMorph>>fitContents
StringMorph>>contents:
StringMorph>>initWithContents:font:emphasis:
StringMorph class>>contents:font:emphasis:
StringMorph class>>contents:font:
StringMorph class>>contents:
TextMorph>>asReadOnlyMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
StringMorph>>measureContents
StringMorph>>fitContents
StringMorph>>contents:
StringMorph>>initWithContents:font:emphasis:
StringMorph class>>contents:font:emphasis:
StringMorph class>>contents:font:
StringMorph class>>contents:
TextMorph>>asReadOnlyMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mGTInspectorTagFilter>>addAndSelectTag:
GTDebuggerInspector(GTInspector)>>initialize
GTDebuggerInspector class(Behavior)>>new
Context>>gtConstructDebuggerInspectorIn:for:
GTGenericStackDebugger>>inspectorIn:on:
[ :anObject | self inspectorIn: GLMCompositePresentation new on: anObject ] in GTGenericStackDebugger>>inspectorIn: in Block: [ :anObject | self inspectorIn: GLMCompositePresen...etc...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
GLMMorphicDynamicRenderer>>render:
GLMMorphicDynamicRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderDynamicPresentation:
GLMDynamicPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
GLMMorphicPaneRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPane:
GLMPane>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
StringMorph>>measureContents
StringMorph>>fitContents
StringMorph>>contents:
StringMorph>>initWithContents:font:emphasis:
StringMorph class>>contents:font:emphasis:
StringMorph class>>contents:font:
StringMorph class>>contents:
TextMorph>>asReadOnlyMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0mGLMPagerScrollBrick>>onSelectedPageChanged
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
GLMPagerModel>>notifyAll:
GLMPagerModel>>notifySelectedPageChanged
GLMPagerModel>>pushPane:smooth:
GLMPagerBrick>>pushPane:
[ :each | container brickRoot pushPane: (self renderObject: each) ] in GLMMorphicPagerRenderer>>render: in Block: [ :each | container brickRoot pushPane: (self rend...etc...
OrderedCollection>>do:
GLMMorphicPagerRenderer>>render:
GLMMorphicPagerRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPager:
GLMPager>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
[0m[31mUser Interrupt
[0mOCKeyedSet>>add:
OCBlockScope(OCAbstractMethodScope)>>addCopyingTemp:
OCBlockScope(OCAbstractMethodScope)>>addCopyingTempToAllScopesUpToDefTemp:
OCASTClosureAnalyzer>>visitVariableNode:
RBArgumentNode(RBVariableNode)>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
OCASTClosureAnalyzer>>visitBlockNode:
RBBlockNode>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
OCASTClosureAnalyzer(RBProgramNodeVisitor)>>visitNode:
OCASTClosureAnalyzer>>visitMethodNode:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
StringMorph>>measureContents
StringMorph>>fitContents
StringMorph>>contents:
StringMorph>>initWithContents:font:emphasis:
StringMorph class>>contents:font:emphasis:
StringMorph class>>contents:font:
StringMorph class>>contents:
TextMorph>>asReadOnlyMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
StringMorph>>measureContents
StringMorph>>fitContents
StringMorph>>contents:
StringMorph>>initWithContents:font:emphasis:
StringMorph class>>contents:font:emphasis:
StringMorph class>>contents:font:
StringMorph class>>contents:
TextMorph>>asReadOnlyMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0mGLMBrickBorder>>color:
GLMBrickBorder>>color:
GLMMorphBrick(GLMBrick)>>borderColor:
GLMPagerWidgetThemer>>selectedPaneStyleFor:
GLMPagerScrollBrick>>onSelectedPageChanged
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
GLMPagerModel>>notifyAll:
GLMPagerModel>>notifySelectedPageChanged
GLMPagerModel>>pushPane:smooth:
GLMPagerBrick>>pushPane:
[ :each | container brickRoot pushPane: (self renderObject: each) ] in GLMMorphicPagerRenderer>>render: in Block: [ :each | container brickRoot pushPane: (self rend...etc...
OrderedCollection>>do:
GLMMorphicPagerRenderer>>render:
GLMMorphicPagerRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPager:
GLMPager>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0m[31mUser Interrupt
[0m[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
[ self mutex
	critical: [ FreeTypeGlyphRenderer current
			glyphOf: aCharacter
			colorValue: aColorValue
			mono: monoBoolean
			subpixelPosition: sub
			font: self ] ] in FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition: in Block: [ self mutex...
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>glyphOf:colorValue:mono:subpixelPosition:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
[ "allow override" self measureContents x ] in LabelMorph>>minWidth in Block: [ "allow override" self measureContents x ]
MorphExtension>>valueOfProperty:ifAbsent:
LabelMorph(Morph)>>valueOfProperty:ifAbsent:
LabelMorph>>minWidth
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
CheckboxMorph(Morph)>>submorphsDo:
TableLayout>>minExtentHorizontal:
TableLayout>>minExtentOf:in:
CheckboxMorph(Morph)>>minExtent
[ :m | 
| sizeX sizeY |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		height := height + sizeY.
		sizeX > width
			ifTrue: [ width := sizeX ] ] ] in TableLayout>>minExtentVertical: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
ClyFormatAsReadSwitchMorph(Morph)>>submorphsDo:
TableLayout>>minExtentVertical:
TableLayout>>minExtentOf:in:
ClyFormatAsReadSwitchMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX |
m disableTableLayout
	ifFalse: [ n := n + 1.
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>minExtentHorizontal: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
Morph>>submorphsDo:
[0mHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
[0m[31mBreak
[0mWAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WAConstruccionDePoemas(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
[0m[31mBreak
[0mWAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WAConstruccionDePoemas(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
[0m[31mBreak
[0mWAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
WAConstruccionDePoemas(WAComponent)>>accept:
WAConstruccionDePoemas(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
[0m[31mMessageNotUnderstood: Poema>>styleDeVerso:para:
[0mPoema(Object)>>doesNotUnderstand: #styleDeVerso:para:
WAVersosAleatorios>>styleDeVerso:
WAVersosAleatorios>>renderVerso:withRenderer:
Verso>>renderOnComponent:withRenderer:
[ :verso | verso renderOnComponent: self withRenderer: html ] in WAVersosAleatorios>>renderVersos:withRenderer: in Block: [ :verso | verso renderOnComponent: self withRende...etc...
OrderedCollection>>do:
WAVersosAleatorios>>renderVersos:withRenderer:
Poema>>renderOnComponent:withRenderer:
[ poemas
	renderOnComponent: (WAVersosAleatorios on: poemas)
	withRenderer: html ] in WAConstruccionDePoemas>>renderPoemas:withRenderer: in Block: [ poemas...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAConstruccionDePoemas>>renderPoemas:withRenderer:
ConstruccionDePoemas>>renderOnComponent:withRenderer:
[ model renderOnComponent: self withRenderer: html.
html div class: 'clear' ] in WAConstruccionDePoemas>>renderContentOn: in Block: [ model renderOnComponent: self withRenderer: html...etc...
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with: in Block: [ self before....
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
[0mMPagerScrollBrick(GLMBrick)>>doLayout
GLMPagerScrollBrick(GLMBrick)>>doLayoutForce
GLMPagerScrollBrick(GLMBrick)>>addBrickBack:
GLMPagerScrollBrick>>band:
GLMPagerScrollBrick>>initialize
GLMPagerScrollBrick class(Behavior)>>new
GLMPagerBrick>>newScrollBrick
GLMPagerBrick>>pagerModel:
GLMMorphicPagerRenderer>>render:
GLMMorphicPagerRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPager:
GLMPager>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GTDebuggerInspector(GLMCompositePresentation)>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderWithTitleOrNil:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mFTTableMorph>>recalculateVerticalScrollBarVisibilityIfHidden:
FTTableMorph>>recalculateVerticalScrollBar
FTTableMorph>>refresh
FTTableMorph>>hideColumnHeaders
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>specificTableMorphColumnsInitialization
GLMMorphicFastTableRenderer>>specificTableMorphInitializiation
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>initializeTableMorph
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>render:
GLMMorphicFastTableRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderFastTablePresentation:
GLMFastTablePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
LazyTabGroupMorph>>pageAt:
LazyTabGroupMorph>>updatePageIndex:
LazyTabGroupMorph(TabGroupMorph)>>update:
LazyTabGroupMorph(Object)>>update:with:
MorphChangedWithArguments>>deliverTo:
LazyTabGroupMorph(Morph)>>handleUpdate:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
[0m[31mUser Interrupt
[0mRxsPiece>>initializeAtom:min:max:
RxsPiece>>initializeAtom:
RxParser>>piece
RxParser>>branch
RxParser>>regex
RxParser>>atom
RxParser>>piece
RxParser>>branch
RxParser>>regex
RxParser>>parseStream:
RxParser>>parse:
ByteString(String)>>asRegex
PharoDocCommentNode class>>docCommentRangesIn:
PharoDocCommentNode class>>parseDocComments:
RBComment>>pharoDocCommentNodes
SHRBTextStyler>>styleDocComment:
[ :comment | self styleDocComment: comment ] in SHRBTextStyler>>visitMethodComments: in Block: [ :comment | self styleDocComment: comment ]
Array(SequenceableCollection)>>do:
SHRBTextStyler>>visitMethodComments:
SHRBTextStyler>>visitMethodNode:
RBMethodNode>>acceptVisitor:
SHRBTextStyler>>style:ast:
SHRBTextStyler>>privateStyle:
SHRBTextStyler(SHTextStyler)>>style:
[ ^ self styler style: aText ] in RubShoutStylerDecorator>>style: in Block: [ ^ self styler style: aText ]
BlockClosure>>on:do:
RubShoutStylerDecorator>>style:
[ aText addAttribute: self defaultFontChange.
next text: (text := self styler format: aText).
replaceStart := 1.
replaceStop := text size.
self style: text ] in RubShoutStylerDecorator>>text: in Block: [ aText addAttribute: self defaultFontChange....
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mMorphExtension>>borderStyle:
GLMPluggableButtonMorph(PluggableButtonMorph)>>changed
GLMPluggableButtonMorph(PluggableButtonMorph)>>paneColorChanged
GLMPluggableButtonMorph(PluggableButtonMorph)>>adoptColor:
GLMPluggableButtonMorph(PluggableButtonMorph)>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in ToolDockingBarMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
ToolDockingBarMorph(Morph)>>submorphsDo:
ToolDockingBarMorph(Morph)>>adoptPaneColor:
ToolDockingBarMorph(DockingBarMorph)>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in GLMPanelMorph>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
GLMPanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in PanelMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
PanelMorph(Morph)>>adoptPaneColor:
PanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in LazyTabGroupMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
LazyTabGroupMorph(Morph)>>submorphsDo:
LazyTabGroupMorph(Morph)>>adoptPaneColor:
LazyTabGroupMorph(TabGroupMorph)>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in GLMPanelMorph>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
GLMPanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in GLMPanelMorph>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
[0m